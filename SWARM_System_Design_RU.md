# SWARM — Документ системного дизайна

**Система оркестрации мультиагентной среды**

Версия 1.0 | Февраль 2026 | Черновик | Внутренний / Конфиденциальный

---

## Содержание

1. [Введение](#1-введение)
2. [Архитектура системы](#2-архитектура-системы)
3. [Технологический стек](#3-технологический-стек)
4. [Проектирование базы данных](#4-проектирование-базы-данных)
5. [Справочник CLI-команд](#5-справочник-cli-команд)
6. [Алгоритм распределения задач](#6-алгоритм-распределения-задач)
7. [Механизм блокировки файлов](#7-механизм-блокировки-файлов)
8. [Жизненный цикл агента](#8-жизненный-цикл-агента)
9. [Жизненный цикл задачи](#9-жизненный-цикл-задачи)
10. [Live-монитор (дашборд)](#10-live-монитор-дашборд)
11. [SKILLS.md — инструкция для агентов](#11-skillsmd--инструкция-для-агентов)
12. [Руководство пользователя](#12-руководство-пользователя)
13. [План реализации](#13-план-реализации)
14. [Риски и меры по снижению](#14-риски-и-меры-по-снижению)
15. [Будущие улучшения (v2)](#15-будущие-улучшения-v2)
16. [Глоссарий](#16-глоссарий)

---

## 1. Введение

### 1.1 Назначение документа

Данный документ описывает полный системный дизайн Swarm — локальной системы оркестрации мультиагентной среды, которая позволяет оператору (Лидеру) управлять несколькими LLM-агентами (Claude, Codex, Gemini и др.), работающими параллельно над общей кодовой базой. Документ предназначен для команды разработки и является основной спецификацией для реализации.

### 1.2 Постановка проблемы

Современная разработка всё активнее использует LLM-агентов в терминале (Claude Code, OpenAI Codex CLI, Gemini CLI) для генерации и редактирования кода. Однако координация нескольких агентов, работающих одновременно над одним проектом, порождает ряд проблем: распределение задач, предотвращение конфликтов при редактировании файлов, мониторинг прогресса и разграничение по ролям. На данный момент не существует лёгкого, локального решения, которое закрывает все эти задачи без облачной инфраструктуры или сложных событийных архитектур.

### 1.3 Цели

- Предоставить единый CLI-интерфейс (`swarm`) для управления мультиагентными рабочими процессами на локальной машине.
- Дать Лидеру возможность создавать, приоритизировать и назначать задачи агентам по типу CLI, имени и роли.
- Предотвращать конфликты при параллельном редактировании файлов.
- Обеспечить мониторинг активности агентов и прогресса задач в реальном времени.
- Работать полностью локально, без сетевых зависимостей.
- Сохранять простоту: никаких бесконечных циклов, событийных слушателей или автономного общения между агентами. Лидер командует явно.

### 1.4 Не-цели

- Автономное общение агентов между собой.
- Облачная очередь задач или брокер сообщений.
- Веб-интерфейс (в v1 — только терминал).
- Автоматическое код-ревью или интеграция с CI/CD.

### 1.5 Ключевые принципы

**Ручное управление:** Лидер явно запускает агентов, создаёт задачи и контролирует результат. Агенты не действуют автономно за пределами своей очереди задач.

**Постоянство сессии:** Терминалы агентов не закрываются после выполнения задач. Агент ждёт следующей команды Лидера. Процессы не умирают.

**Детерминированное назначение:** Задачи сопоставляются с агентами через строгую цепочку фильтров (роль → имя → тип CLI). Никакой неоднозначности, никаких ложных срабатываний.

**Безопасность файлов:** Атомарная блокировка файлов предотвращает одновременное редактирование. Агент, который не может заблокировать файл, ждёт его освобождения.

---

## 2. Архитектура системы

### 2.1 Общий обзор

Swarm — это локальная система, работающая на одной машине. Она состоит из трёх логических ролей, которые общаются исключительно через общую базу данных SQLite:

**Терминал Лидера:** Основной терминал оператора. Используется для инициализации среды, создания задач, мониторинга и управления агентами.

**Терминалы агентов:** По одному терминалу на каждого LLM-агента. В каждом запущен реальный CLI-инструмент (Claude, Codex, Gemini) в YOLO/auto-accept режиме. Агент читает инструкции из файла SKILLS.md и взаимодействует со Swarm через CLI-команды.

**Терминал монитора:** Отдельный терминал с запущенной командой `swarm monitor`, которая отображает live-дашборд со всеми агентами, задачами и блокировками файлов.

### 2.2 Модель коммуникации

Вся межпроцессная коммуникация происходит через SQLite. Нет сокетов, пайпов, разделяемой памяти или брокеров сообщений. Каждый процесс (CLI Лидера, CLI агента, монитор) читает и пишет в один и тот же файл базы данных. Режим WAL (Write-Ahead Logging) включён для поддержки параллельного чтения при одном писателе, что достаточно для данного сценария использования.

### 2.3 Диаграмма компонентов

```
+---------------------+     +---------------------+     +---------------------+
|  Терминал Лидера    |     |  Терминал Агента 1  |     |  Терминал Агента N  |
|                     |     |                     |     |                     |
|  swarm init         |     |  claude (YOLO mode) |     |  codex (YOLO mode)  |
|  swarm task add     |     |  swarm join         |     |  swarm join         |
|  swarm agents       |     |  swarm next         |     |  swarm next         |
|  swarm start        |     |  swarm lock         |     |  swarm lock         |
+----------+----------+     |  swarm done         |     |  swarm done         |
           |                +----------+----------+     +----------+----------+
           |                           |                           |
           +---------------------------+---------------------------+
                                       |
                              +--------v--------+
                              |    swarm.db     |
                              |    (SQLite)     |
                              +--------+--------+
                                       |
                              +--------v--------+
                              | Терминал Монитора|
                              | swarm monitor    |
                              +-----------------+
```

### 2.4 Модель развёртывания

Swarm работает целиком на одной машине с Windows 11. Лидер открывает несколько окон PowerShell. В каждом терминале агента Лидер вручную запускает соответствующий CLI-инструмент (например, `claude`, `codex`), переключает его в YOLO-режим и просит зарегистрироваться в Swarm. Никаких контейнеров, виртуальных машин или сетевых сервисов.

---

## 3. Технологический стек

### 3.1 Основные технологии

| Технология | Назначение | Обоснование |
|---|---|---|
| Python 3.11+ | CLI-приложение, вся бизнес-логика | Богатая экосистема, библиотеки typer/rich, кроссплатформенность |
| SQLite (WAL) | Центральная БД для задач, агентов, блокировок, логов | Без конфигурации, файловая, атомарные транзакции, достаточная конкурентность |
| Typer | CLI-фреймворк | На основе type-hints, автогенерация help, чистый API |
| Rich | Терминальный UI / live-дашборд | Красивые таблицы, live-обновление, прогресс-бары, панели |
| Click (через Typer) | Парсинг аргументов | Поставляется с Typer, проверенная надёжность |
| PyInstaller (опционально) | Сборка в .exe | Один бинарник для Windows, без установки Python |

### 3.2 Инструменты разработки

| Инструмент | Назначение |
|---|---|
| pytest | Юнит- и интеграционное тестирование |
| ruff | Линтинг и форматирование |
| pre-commit | Git-хуки для контроля качества кода |

### 3.3 Отвергнутые альтернативы

**PostgreSQL / MySQL:** Избыточно для локальной системы на одной машине. Требует запуска серверного процесса. SQLite закрывает все потребности без какой-либо конфигурации.

**Redis / RabbitMQ:** Брокеры сообщений добавляют инфраструктурную сложность. Поллинг SQLite в WAL-режиме обеспечивает достаточную производительность для 3–10 параллельных агентов.

**FastAPI / WebSockets:** В v1 нет веб-интерфейса. Всё взаимодействие через терминал. Добавление веб-слоя увеличит сложность без очевидной выгоды на данном этапе.

**Docker:** Агенты — это реальные CLI-процессы в PowerShell. Контейнеризация усложнит работу с локальными файлами и файловой системой хоста.

---

## 4. Проектирование базы данных

### 4.1 Общие сведения

Файл базы данных (`swarm.db`) создаётся командой `swarm init` в текущей директории. WAL-режим включается при создании для поддержки параллельного чтения. Все таблицы используют автоинкрементные целочисленные первичные ключи.

### 4.2 Таблица: `agents`

Хранит всех зарегистрированных агентов и их текущее состояние.

| Колонка | Тип | Ограничения | Описание |
|---|---|---|---|
| agent_id | INTEGER | PK, AUTO | Уникальный идентификатор сессии агента |
| session_token | TEXT | UNIQUE, NOT NULL | UUID v4, генерируется при регистрации. Привязывает агента к терминальной сессии. |
| cli_type | TEXT | NOT NULL | Тип терминального CLI: `claude`, `codex`, `gemini` и т.д. |
| name | TEXT | NOT NULL | Человекочитаемое имя, которое агент выбирает при регистрации |
| role | TEXT | NOT NULL | Функциональная роль: `architect`, `developer`, `tester`, `devops` и т.д. |
| status | TEXT | DEFAULT `idle` | Текущее состояние: `idle`, `working`, `waiting`, `done` |
| current_task_id | INTEGER | FK tasks, NULL | ID задачи, которая сейчас выполняется |
| registered_at | DATETIME | NOT NULL | Время регистрации |
| last_heartbeat | DATETIME | NOT NULL | Обновляется при каждой команде `swarm` |
| pid | INTEGER | NULLABLE | PID процесса ОС для определения живости |

### 4.3 Таблица: `tasks`

Центральная очередь задач с полями фильтрации и приоритетов.

| Колонка | Тип | Ограничения | Описание |
|---|---|---|---|
| task_id | INTEGER | PK, AUTO | Уникальный идентификатор задачи |
| description | TEXT | NOT NULL | Полное текстовое описание задачи |
| priority | INTEGER | DEFAULT 3 | Приоритет от 1 (наивысший) до 5 (наименьший) |
| target_cli | TEXT | NULLABLE | Требуемый тип CLI, или NULL для любого |
| target_name | TEXT | NULLABLE | Требуемое имя агента, или NULL для любого |
| target_role | TEXT | NULLABLE | Требуемая роль агента, или NULL для любой |
| status | TEXT | DEFAULT `pending` | `pending` \| `in_progress` \| `done` \| `blocked` |
| assigned_to | INTEGER | FK agents, NULL | Назначенный агент |
| depends_on | INTEGER | FK tasks, NULL | Задача, которая должна быть завершена первой |
| summary | TEXT | NULLABLE | Резюме агента по завершении |
| created_at | DATETIME | NOT NULL | Время создания |
| started_at | DATETIME | NULLABLE | Время взятия в работу |
| completed_at | DATETIME | NULLABLE | Время завершения |

### 4.4 Таблица: `file_locks`

Отслеживает, какие файлы заблокированы каким агентом.

| Колонка | Тип | Ограничения | Описание |
|---|---|---|---|
| lock_id | INTEGER | PK, AUTO | Уникальный идентификатор блокировки |
| file_path | TEXT | UNIQUE, NOT NULL | Относительный путь к заблокированному файлу |
| locked_by | INTEGER | FK agents, NOT NULL | Агент, удерживающий блокировку |
| task_id | INTEGER | FK tasks, NOT NULL | Задача, для которой получена блокировка |
| locked_at | DATETIME | NOT NULL | Время получения блокировки |

### 4.5 Таблица: `task_log`

Неизменяемый лог событий, используемый дашбордом монитора.

| Колонка | Тип | Ограничения | Описание |
|---|---|---|---|
| log_id | INTEGER | PK, AUTO | Уникальный идентификатор записи |
| task_id | INTEGER | FK tasks, NULL | Связанная задача |
| agent_id | INTEGER | FK agents, NULL | Агент, сгенерировавший событие |
| event | TEXT | NOT NULL | Тип события: `task_started`, `task_done`, `file_locked`, `file_unlocked`, `waiting_for_lock`, `error` |
| message | TEXT | NULLABLE | Произвольный текст сообщения |
| timestamp | DATETIME | NOT NULL | Время события |

### 4.6 Индексы

- `idx_tasks_status_priority` ON tasks(status, priority) — быстрый выбор задач
- `idx_tasks_assigned` ON tasks(assigned_to) — задачи агента
- `idx_file_locks_path` ON file_locks(file_path) — проверка конфликтов блокировок
- `idx_task_log_task` ON task_log(task_id) — история задачи
- `idx_agents_session` ON agents(session_token) — аутентификация по сессии

### 4.7 SQL-схема

```sql
PRAGMA journal_mode=WAL;

CREATE TABLE agents (
  agent_id       INTEGER PRIMARY KEY AUTOINCREMENT,
  session_token  TEXT    UNIQUE NOT NULL,
  cli_type       TEXT    NOT NULL,
  name           TEXT    NOT NULL,
  role           TEXT    NOT NULL,
  status         TEXT    NOT NULL DEFAULT 'idle',
  current_task_id INTEGER REFERENCES tasks(task_id),
  registered_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  last_heartbeat DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  pid            INTEGER
);

CREATE TABLE tasks (
  task_id      INTEGER PRIMARY KEY AUTOINCREMENT,
  description  TEXT    NOT NULL,
  priority     INTEGER NOT NULL DEFAULT 3,
  target_cli   TEXT,
  target_name  TEXT,
  target_role  TEXT,
  status       TEXT    NOT NULL DEFAULT 'pending',
  assigned_to  INTEGER REFERENCES agents(agent_id),
  depends_on   INTEGER REFERENCES tasks(task_id),
  summary      TEXT,
  created_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  started_at   DATETIME,
  completed_at DATETIME
);

CREATE TABLE file_locks (
  lock_id    INTEGER PRIMARY KEY AUTOINCREMENT,
  file_path  TEXT    UNIQUE NOT NULL,
  locked_by  INTEGER NOT NULL REFERENCES agents(agent_id),
  task_id    INTEGER NOT NULL REFERENCES tasks(task_id),
  locked_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE task_log (
  log_id    INTEGER PRIMARY KEY AUTOINCREMENT,
  task_id   INTEGER REFERENCES tasks(task_id),
  agent_id  INTEGER REFERENCES agents(agent_id),
  event     TEXT    NOT NULL,
  message   TEXT,
  timestamp DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_tasks_status_priority ON tasks(status, priority);
CREATE INDEX idx_tasks_assigned ON tasks(assigned_to);
CREATE INDEX idx_file_locks_path ON file_locks(file_path);
CREATE INDEX idx_task_log_task ON task_log(task_id);
CREATE INDEX idx_agents_session ON agents(session_token);
```

---

## 5. Справочник CLI-команд

### 5.1 Общее поведение

Все команды вызываются через единый бинарник `swarm`. CLI автоматически ищет `swarm.db` в текущей директории и родительских. Каждая команда, изменяющая состояние, пишет запись в `task_log` для аудита. Все команды агента аутентифицируются по `session_token` из файла `.swarm_session`.

### 5.2 Команды Лидера

#### `swarm init`

Инициализирует среду Swarm в текущей директории. Создаёт `swarm.db` с полной схемой, включает WAL-режим, генерирует файл `SKILLS.md` по умолчанию.

```
Использование: swarm init
Вывод: Swarm initialized. Database: ./swarm.db
```

#### `swarm task add`

Создаёт новую задачу в очереди. Возвращает присвоенный ID задачи.

```
Использование: swarm task add --desc ТЕКСТ --priority ЧИСЛО
  [--cli ТЕКСТ] [--name ТЕКСТ] [--role ТЕКСТ] [--depends-on ЧИСЛО]

Параметры:
  --desc ТЕКСТ        Описание задачи (обязательно)
  --priority ЧИСЛО     От 1 (наивысший) до 5 (наименьший), по умолчанию 3
  --cli ТЕКСТ         Фильтр по типу CLI
  --name ТЕКСТ        Фильтр по имени агента
  --role ТЕКСТ        Фильтр по роли агента
  --depends-on ЧИСЛО   ID задачи-зависимости
```

#### `swarm task list`

Отображает все задачи с текущим статусом, назначением и приоритетом.

```
Использование: swarm task list [--status pending] [--agent ТЕКСТ] [--priority ЧИСЛО]
```

#### `swarm agents`

Выводит список всех зарегистрированных агентов с ID, типом CLI, именем, ролью, статусом и текущей задачей.

```
Использование: swarm agents [--cleanup]
```

#### `swarm monitor`

Запускает live-дашборд с 4 панелями в терминале. Обновляется каждые 2 секунды.

```
Использование: swarm monitor [--refresh ЧИСЛО]
```

#### `swarm start`

Устанавливает флаг старта в базе данных, сигнализируя агентам начать обработку задач.

```
Использование: swarm start --all | --agent ТЕКСТ | --cli ТЕКСТ
```

#### `swarm unlock --force`

Команда Лидера для принудительного снятия зависших блокировок файлов.

```
Использование: swarm unlock --force --file ПУТЬ
```

### 5.3 Команды агента

#### `swarm join`

Регистрирует агента в системе. Генерирует UUID v4 `session_token`, сохраняет его в `.swarm_session`. Интерактивно запрашивает тип CLI, имя и роль.

```
Использование: swarm join

Запросы:
  Тип CLI (claude/codex/gemini): claude
  Имя агента: alice
  Роль (architect/developer/tester/devops): architect

Вывод: Registered as agent #3 (claude/alice/architect). Session saved.
```

#### `swarm next`

Получает следующую подходящую задачу. Применяет цепочку фильтров (см. Раздел 6). Атомарно помечает задачу как `in_progress`. Возвращает описание задачи или сообщение «нет задач».

```
Использование: swarm next

Вывод (задача найдена):  Task #7 [P1]: Спроектировать REST API
Вывод (пусто):           No matching tasks in queue.
```

#### `swarm lock`

Захватывает блокировки на указанные файлы. Если файл занят другим агентом — блокируется и проверяет каждые 3 секунды до освобождения. Захват атомарный через UNIQUE constraint.

```
Использование: swarm lock ФАЙЛ [ФАЙЛ...] [--timeout 300]

Вывод: Locked: file1.py, file2.py
       Waiting for file1.py (locked by agent #2)...
```

#### `swarm done`

Помечает текущую задачу как завершённую. Автоматически снимает все блокировки файлов по данной задаче. Записывает резюме.

```
Использование: swarm done --summary ТЕКСТ
```

#### `swarm status`

Показывает текущее состояние агента: активная задача, ожидающие задачи, заблокированные файлы.

```
Использование: swarm status
```

---

## 6. Алгоритм распределения задач

### 6.1 Цепочка фильтров

Когда агент вызывает `swarm next`, все задачи со статусом `pending` оцениваются по профилю агента. Каждый фильтр применяется последовательно. Задача должна пройти ВСЕ применимые фильтры:

**Шаг 1 — Проверка зависимостей:** Если `task.depends_on` установлен, указанная задача должна иметь `status = done`. Иначе — пропуск.

**Шаг 2 — Фильтр по роли (жёсткий):** Если `task.target_role` задан, `agent.role` ДОЛЖНА совпадать. Без исключений. Если ни у одного агента в системе нет нужной роли — задача остаётся в `pending` бессрочно. Это сделано намеренно — агент не должен выполнять задачу вне своей роли.

**Шаг 3 — Фильтр по имени (жёсткий):** Если `task.target_name` задан, `agent.name` ДОЛЖНО совпадать точно.

**Шаг 4 — Фильтр по типу CLI (жёсткий):** Если `task.target_cli` задан, `agent.cli_type` ДОЛЖЕН совпадать точно.

**Шаг 5 — Сортировка по приоритету:** Из оставшихся подходящих задач выбирается задача с наименьшим номером приоритета (наивысший приоритет). При равенстве — по `task_id` (самая старая первой).

### 6.2 SQL-запрос

```sql
BEGIN IMMEDIATE;

SELECT task_id FROM tasks
WHERE status = 'pending'
  AND (depends_on IS NULL
       OR depends_on IN (SELECT task_id FROM tasks WHERE status = 'done'))
  AND (target_role IS NULL OR target_role = :agent_role)
  AND (target_name IS NULL OR target_name = :agent_name)
  AND (target_cli  IS NULL OR target_cli  = :agent_cli)
ORDER BY priority ASC, task_id ASC
LIMIT 1;

-- Если строка найдена:
UPDATE tasks SET status = 'in_progress', assigned_to = :agent_id,
  started_at = CURRENT_TIMESTAMP WHERE task_id = :selected_id;

COMMIT;
```

### 6.3 Сценарии распределения

**Сценарий А: Три разных типа CLI.** Агенты: codex-1 (codex/dev), claude-1 (claude/dev), gemini-1 (gemini/dev). Задачи распределяются исключительно по `target_cli`. Каждый агент видит только задачи своего типа.

**Сценарий Б: Три агента одного типа CLI.** Агенты: claude-alice (claude/architect), claude-bob (claude/developer), claude-carol (claude/tester). Задачи различаются по `target_name` или `target_role`.

**Сценарий В: Задача с ограничением по роли.** Задача с `target_role=architect` доступна только агенту с ролью `architect`, вне зависимости от типа CLI или имени. Если архитектора нет — задача ждёт.

**Сценарий Г: Задача без ограничений.** Задача со всеми полями target = NULL может быть подхвачена любым свободным агентом. Первый, кто вызовет `swarm next`, получит её (атомарная транзакция исключает двойное назначение).

---

## 7. Механизм блокировки файлов

### 7.1 Назначение

Когда несколько агентов работают параллельно над одной кодовой базой, одновременное редактирование одного файла приводит к повреждению данных или потере изменений. Механизм блокировки гарантирует, что только один агент может редактировать конкретный файл в любой момент времени.

### 7.2 Жизненный цикл блокировки

1. Агент анализирует задачу и определяет, какие файлы будет редактировать.
2. Агент вызывает `swarm lock file1.py file2.py` для резервирования файлов.
3. Система проверяет таблицу `file_locks`. Если файл свободен — выполняется атомарный INSERT (UNIQUE constraint).
4. Если файл заблокирован другим агентом — команда входит в цикл поллинга (каждые 3 секунды), в лог записывается событие `waiting_for_lock`.
5. Агент выполняет работу с заблокированными файлами.
6. Агент вызывает `swarm done` — все блокировки по этой задаче автоматически снимаются (`DELETE WHERE locked_by = :agent AND task_id = :task`).

### 7.3 Разрешение конфликтов

**Атомарность:** Захват блокировки использует INSERT с UNIQUE constraint на `file_path`. Если два агента пытаются одновременно — ровно один успеет; второй получит нарушение ограничения и войдёт в цикл ожидания.

**Таймаут:** `swarm lock` принимает `--timeout` (по умолчанию 300 секунд). Если файл не освободится за это время — команда завершается ошибкой, агент логирует событие `error`.

**Предотвращение дедлоков:** Агенты должны запрашивать все блокировки в одном вызове `swarm lock`. Система сортирует файлы в алфавитном порядке и захватывает блокировки в этом порядке, предотвращая циклические ожидания.

**Восстановление зависших блокировок:** Монитор подсвечивает блокировки, удерживаемые дольше 30 минут. Лидер может принудительно снять их командой `swarm unlock --force --file <путь>`.

---

## 8. Жизненный цикл агента

### 8.1 Машина состояний

```
  +-------------------+
  | НЕ ЗАРЕГИСТРИРОВАН |
  +--------+----------+
           | swarm join
  +--------v----------+
  |      IDLE         |<----------------------------+
  +--------+----------+                             |
           | swarm next (задача найдена)             |
  +--------v----------+                             |
  |     WORKING       |----+                        |
  +--------+----------+    | swarm lock (заблокирован)|
           |               |                        |
           |        +------v------+                 |
           |        |   WAITING   |                 |
           |        +------+------+                 |
           |               | (файл освобождён)      |
           |<--------------+                        |
           |                                        |
           | swarm done                             |
           +----------------------------------------+
             (swarm next: нет задач -> IDLE)
```

### 8.2 Рабочий процесс агента (с точки зрения LLM)

LLM-агент читает `SKILLS.md` и выполняет точно следующую последовательность:

1. Вызвать `swarm join` для регистрации (тип CLI, имя, роль).
2. Ждать команду Лидера на начало работы.
3. Вызвать `swarm next` для получения следующей задачи.
4. Проанализировать задачу. Определить, какие файлы будут затронуты.
5. Вызвать `swarm lock <файлы>` для резервирования файлов.
6. Выполнить работу (написать код, отредактировать файлы и т.д.).
7. Вызвать `swarm done --summary "..."` для отметки завершения задачи.
8. Немедленно вызвать `swarm next` снова. Если задача получена — перейти к шагу 4.
9. Если задач больше нет — остановиться и ждать следующей команды Лидера. НЕ спрашивать — просто ждать.

### 8.3 Идентификация сессии

При регистрации каждый агент получает UUID v4 `session_token`, который сохраняется в файле `.swarm_session`. Этот токен передаётся с каждой командой и однозначно соответствует `agent_id` в базе данных. Даже если два агента имеют одинаковое имя, их задачи и блокировки никогда не перепутаются.

### 8.4 Heartbeat и определение живости

Каждая команда `swarm` обновляет `last_heartbeat`. Монитор помечает агентов без активности более 5 минут как потенциально мёртвых.

---

## 9. Жизненный цикл задачи

### 9.1 Переходы состояний

```
pending --------> in_progress    (агент вызывает swarm next)
pending --------> blocked        (зависимость ещё не завершена)
blocked --------> pending        (зависимость завершена)
in_progress ----> done           (агент вызывает swarm done)
```

### 9.2 Создание задач

Лидер создаёт задачи через `swarm task add`. Каждая задача может опционально указывать `target_cli`, `target_name`, `target_role` и `depends_on`. Эти поля определяют, какие агенты могут взять задачу и когда она станет доступной.

### 9.3 Завершение задачи

Когда агент вызывает `swarm done --summary "..."`, система атомарно: обновляет статус задачи на `done`, записывает резюме и `completed_at`, снимает все блокировки файлов по данной задаче, устанавливает `current_task_id` агента в NULL и статус в `idle`, логирует событие.

---

## 10. Live-монитор (дашборд)

### 10.1 Обзор

`swarm monitor` запускает полноэкранный терминальный дашборд на основе Rich Live. Обновляется каждые 2 секунды (настраиваемо), читая всё состояние из SQLite.

### 10.2 Макет дашборда

```
+-------------------------------+-------------------------------+
|       ПАНЕЛЬ АГЕНТОВ          |       ПАНЕЛЬ ЗАДАЧ            |
|                               |                               |
|  #1 claude/alice/architect    |  #7  [P1] Дизайн API  [WORK] |
|     Статус: WORKING [Task#7]  |  #8  [P2] Тесты       [PEND] |
|     Heartbeat: 12с назад      |  #9  [P3] Рефакторинг [DONE] |
|                               |  #10 [P1] Деплой      [BLCK] |
|  #2 codex/bob/developer       |                               |
|     Статус: IDLE              |                               |
|     Heartbeat: 5с назад       |                               |
+-------------------------------+-------------------------------+
|    ПАНЕЛЬ БЛОКИРОВОК          |    ПАНЕЛЬ АКТИВНОСТИ          |
|                               |                               |
|  src/api.py -> alice [12мин]  |  14:32 alice: Task #7 начата  |
|  src/db.py  -> alice [12мин]  |  14:31 bob:   Task #6 готова  |
|                               |  14:30 alice: Lock api.py     |
+-------------------------------+-------------------------------+
```

### 10.3 Описание панелей

**Панель агентов:** ID, тип CLI, имя, роль, статус (цветовая кодировка: зелёный = working, жёлтый = waiting, серый = idle, красный = мёртв), текущая задача, время последнего heartbeat.

**Панель задач:** ID задачи, бейдж приоритета, описание (усечённое), статус, назначенный агент. Сортировка по приоритету. Завершённые задачи скрыты по умолчанию.

**Панель блокировок:** Путь к файлу, имя блокирующего агента, длительность блокировки. Блокировки старше 30 минут подсвечиваются красным.

**Панель активности:** Последние 20 событий в обратном хронологическом порядке. Время, имя агента, тип события, сообщение.

### 10.4 Управление клавиатурой

- `q` — Выход из монитора
- `d` — Показать/скрыть завершённые задачи
- `r` — Принудительное обновление
- `1/2/3/4` — Развернуть конкретную панель на весь экран

---

## 11. SKILLS.md — Инструкция для агентов

### 11.1 Назначение

`SKILLS.md` — это файл в формате Markdown, размещённый в корне проекта. LLM-агенты читают его, чтобы понять, как взаимодействовать со Swarm. Когда Лидер говорит агенту «Прочитай SKILLS.md и начинай работать», LLM парсит этот файл и автономно следует инструкциям.

### 11.2 Обязательные разделы

**Обзор системы:** Что такое Swarm, какова роль агента в системе.

**Регистрация:** Пошаговая инструкция по `swarm join`.

**Цикл выполнения задач:** Точная последовательность команд: `swarm next` → анализ → `swarm lock` → работа → `swarm done` → повтор. Без пауз, без подтверждений между задачами.

**Правила блокировки файлов:** Всегда блокировать перед редактированием. Перечислить ВСЕ файлы, которые планируется изменить. Ждать, если файл занят.

**Рекомендации по резюме:** Как писать `--summary`: кратко, перечисляя что было изменено и почему.

**Обработка ошибок:** Нет задач → ждать. Таймаут блокировки → пропустить и сообщить. Никогда не продолжать без блокировок.

**Запрещённые действия:** Никогда не редактировать без блокировки. Никогда не вызывать `done` без завершения задачи. Никогда не модифицировать `swarm.db` напрямую.

### 11.3 Доставка

Файл автоматически генерируется командой `swarm init` с содержимым по умолчанию. Лидер может настроить его перед подключением агентов.

---

## 12. Руководство пользователя

### 12.1 Быстрый старт

1. Установить: `pip install swarm-orchestrator` (или скачать `.exe`).
2. Перейти в директорию проекта.
3. Выполнить `swarm init`.
4. Создать задачи: `swarm task add --desc "..." --priority 1 --cli claude`.
5. Открыть новое окно PowerShell, запустить CLI агента (например, `claude`), переключить в YOLO-режим.
6. Сказать агенту: «Прочитай SKILLS.md в корне проекта и зарегистрируйся через `swarm join`.»
7. Повторить для каждого агента.
8. Открыть ещё один терминал: `swarm monitor`.
9. Сказать каждому агенту: «Начинай работать.» Агент выполнит `swarm next` и начнёт автономно.
10. Следить за прогрессом. Добавлять задачи по мере необходимости.

### 12.2 Лучшие практики

- Создавайте все задачи до запуска агентов для корректного порядка по приоритетам.
- Используйте фильтрацию по ролям для специализированных задач (архитектура, тестирование).
- Используйте фильтрацию по имени только когда конкретный агент имеет контекст из предыдущей задачи.
- Пишите описания задач чётко и однозначно — агенты это LLM, им нужны ясные инструкции.
- Следите за длительностью блокировок файлов — долгие блокировки могут указывать на зависший агент.
- Используйте `depends_on` для последовательных рабочих процессов.

---

## 13. План реализации

### 13.1 Фаза 1 — Фундамент (Неделя 1)

Цель: Минимально работающая система с базой данных, регистрацией и созданием задач.

1. Каркас проекта: Python-пакет, `pyproject.toml`, зависимости.
2. Модуль базы данных: менеджер подключений SQLite, создание схемы, WAL-режим.
3. `swarm init`: создание базы данных, генерация `SKILLS.md`.
4. `swarm task add` / `swarm task list`.
5. `swarm join`: интерактивная регистрация, генерация session token, файл `.swarm_session`.
6. `swarm agents`: список зарегистрированных агентов.
7. Юнит-тесты для слоя базы данных и создания задач.

### 13.2 Фаза 2 — Распределение и выполнение задач (Неделя 2)

Цель: Агенты могут получать и завершать задачи с корректной фильтрацией.

1. Алгоритм сопоставления задач (роль → имя → тип CLI).
2. `swarm next`: атомарный захват задачи с `BEGIN IMMEDIATE`.
3. `swarm done`: завершение задачи, сохранение резюме, обновление статусов.
4. Разрешение зависимостей (`depends_on`).
5. `swarm status` для агентов.
6. Интеграционные тесты: симуляция параллельных агентов.

### 13.3 Фаза 3 — Блокировка файлов (Неделя 3)

Цель: Безопасность параллельной работы с файлами.

1. Таблица блокировок, UNIQUE constraint.
2. `swarm lock`: атомарный захват, ожидание с поллингом, таймаут.
3. Автоматическое снятие блокировок при `swarm done`.
4. Предотвращение дедлоков (алфавитный порядок захвата).
5. `swarm unlock --force` для зависших блокировок.
6. Нагрузочные тесты: сценарии конкурентного захвата.

### 13.4 Фаза 4 — Дашборд монитора (Неделя 4)

Цель: Визуализация состояния в реальном времени.

1. Rich Live дашборд: макет из 4 панелей.
2. Панель агентов с цветовой кодировкой статусов.
3. Панель задач с сортировкой по приоритету.
4. Панель блокировок с обнаружением зависших.
5. Панель активности с последними событиями.
6. Управление клавиатурой.

### 13.5 Фаза 5 — Документация и тестирование (Неделя 5)

Цель: Продакшен-готовая документация.

1. Шаблон `SKILLS.md`.
2. `USER_GUIDE.md`.
3. `--help` для каждой CLI-команды.
4. Сквозные тесты с реальными LLM-агентами.
5. Исправление багов и полировка.

### 13.6 Фаза 6 — Упаковка и дистрибуция (Неделя 6)

Цель: Простая установка.

1. PyPI-пакет (`pip install swarm-orchestrator`).
2. Сборка Windows `.exe` через PyInstaller.
3. `README.md`, GitHub-репозиторий, CI.

---

## 14. Риски и меры по снижению

| Риск | Влияние | Вероятность | Мера по снижению |
|---|---|---|---|
| Конкуренция записи SQLite (10+ агентов) | Высокое | Средняя | WAL-режим, короткие транзакции (<50мс). Миграция на PostgreSQL при необходимости. |
| LLM-агент игнорирует SKILLS.md | Среднее | Высокая | Простые нумерованные инструкции. Валидация в CLI-командах. Тестирование с каждым типом CLI. |
| Крах агента оставляет зависшие блокировки | Высокое | Средняя | Мониторинг heartbeat. `swarm unlock --force`. Подсветка зависших блокировок в мониторе. |
| Агенты редактируют файлы без блокировки | Высокое | Низкая | SKILLS.md запрещает это. Контроль на уровне CLI. Требуется соблюдение агентом. |
| Голодание задач (низкий приоритет) | Низкое | Средняя | Лидер отслеживает и корректирует. В будущем: механизм старения приоритетов. |
| Потеря session token | Среднее | Низкая | Повторная регистрация через `swarm join`. Очистка через `swarm agents --cleanup`. |

---

## 15. Будущие улучшения (v2)

- Веб-монитор (FastAPI + WebSocket + React).
- Обмен сообщениями между агентами для передачи контекста.
- Автоматическая декомпозиция высокоуровневых целей в подзадачи.
- Интеграция с Git: автоматическое создание веток по задачам, авто-коммит при `done`.
- Шаблоны задач для повторяющихся рабочих процессов.
- Система плагинов для пользовательских типов CLI.
- Метрики: время на задачу, утилизация агентов, пропускная способность.
- Бэкенд на PostgreSQL для развёртывания на нескольких машинах.
- Система уведомлений (Telegram, Slack) о завершении задач.

---

## 16. Глоссарий

**Лидер (Leader)** — Человек-оператор, который создаёт задачи, управляет агентами и контролирует результаты.

**Агент (Agent)** — LLM-инструмент в терминале, зарегистрированный в Swarm.

**Тип CLI (CLI Type)** — Тип терминального агента: `claude`, `codex`, `gemini` и т.д.

**Роль (Role)** — Функциональная роль при регистрации: `architect`, `developer`, `tester`, `devops`.

**Session Token** — UUID v4, привязывающий агента к его терминальной сессии. Хранится в `.swarm_session`.

**YOLO-режим** — Режим автоподтверждения в CLI LLM-агентов — агент выполняет команды без запроса подтверждения от человека.

**SKILLS.md** — Файл инструкций, который LLM-агенты читают для понимания взаимодействия со Swarm.

**Блокировка файла (File Lock)** — Резервирование на уровне базы данных, запрещающее другим агентам редактировать файл.

**Heartbeat** — Временная метка, обновляемая при каждой команде `swarm`; используется для обнаружения мёртвых агентов.

**WAL-режим** — Write-Ahead Logging в SQLite — параллельное чтение при одном писателе.

**Цепочка фильтров (Filter Chain)** — Алгоритм сопоставления задач: роль → имя → тип CLI.
